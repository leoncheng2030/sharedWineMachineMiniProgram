/**
 * ËìùÁâôËÆæÂ§áÊìç‰ΩúÂ∑•ÂÖ∑Á±ª
 * @description ÂåÖÂê´ËìùÁâôËÆæÂ§áËøûÊé•„ÄÅÊï∞ÊçÆ‰º†ËæìÁ≠âÂäüËÉΩ
 * @author WQSÂõ¢Èòü
 * @date 2025-01-30
 * @version 3.0.0 - Âü∫‰∫éÂéüÂßã index.js ÈáçÊûÑÔºåÁÆÄÂåñÊû∂ÊûÑÔºåÊèêÂçáÊÄßËÉΩ
 * 
 * ## üöÄ Êñ∞ÁâàÊú¨ÁâπÊÄß
 * 
 * ### ‚ú® ‰∏ªË¶ÅÊîπËøõ
 * - **ÁÆÄÂåñÊû∂ÊûÑ**: Âü∫‰∫éÂéüÂßã index.js ‰ª£Á†ÅÁªìÊûÑÔºåÂéªÈô§Â§çÊùÇÁöÑÁ±ªÂ∞ÅË£Ö
 * - **TypeScript ÊîØÊåÅ**: Ê∑ªÂä†ÂÆåÊï¥ÁöÑÁ±ªÂûãÂÆö‰πâÔºåÊèêÂçáÂºÄÂèë‰ΩìÈ™å
 * - **ÊÄßËÉΩ‰ºòÂåñ**: ‰ºòÂåñË∂ÖÊó∂Êó∂Èó¥ÂíåÊêúÁ¥¢Á≠ñÁï•ÔºåÊèêÂçáÊ£ÄÊµãÈÄüÂ∫¶
 * - **ÂêëÂêéÂÖºÂÆπ**: ‰øùÊåÅÂéüÊúâ API Êé•Âè£‰∏çÂèò
 * - **ÈîôËØØÂ§ÑÁêÜ**: ÂÆåÂñÑÁöÑÈîôËØØÂ§ÑÁêÜÊú∫Âà∂
 * 
 * ### üîß ‰ΩøÁî®ÊñπÂºè
 * 
 * #### 1. Ê£ÄÊü•ËÆæÂ§áÊòØÂê¶Âú®Á∫ø
 * ```typescript
 * import { checkDeviceOnline } from '@/utils/ble'
 * 
 * const isOnline = await checkDeviceOnline(12345)
 * if (isOnline) {
 *   console.log('ËÆæÂ§áÂú®Á∫ø')
 * } else {
 *   console.log('ËÆæÂ§áÁ¶ªÁ∫ø')
 * }
 * ```
 * 
 * #### 2. ÂÜôÂÖ•ÂÖÖÁîµÊï∞ÊçÆ
 * ```typescript
 * import { writeChargeData } from '@/utils/ble'
 * 
 * const CMD = "your_command_string_here"
 * await writeChargeData(12345, CMD)
 * ```
 * 
 * #### 3. Ê£ÄÊü•ËìùÁâôÊùÉÈôê
 * ```typescript
 * import { checkBluetooth } from '@/utils/ble'
 * 
 * const hasPermission = await checkBluetooth()
 * ```
 */

// Loading ÁÆ°ÁêÜÂô®
class LoadingManager {
  private static instance: LoadingManager;
  private _isLoading: boolean = false;
  private _loadingTimer: any = null;
  private _currentTitle: string = '';

  static getInstance(): LoadingManager {
    if (!LoadingManager.instance) {
      LoadingManager.instance = new LoadingManager();
    }
    return LoadingManager.instance;
  }

  show(title: string = 'Âä†ËΩΩ‰∏≠'): void {
    if (this._isLoading && this._currentTitle === title) {
      return; // Áõ∏ÂêåÊ†áÈ¢òÁöÑloadingÂ∑≤ÁªèÂú®ÊòæÁ§∫Ôºå‰∏çÈáçÂ§çÊòæÁ§∫
    }

    this.hide(); // ÂÖàÈöêËóè‰πãÂâçÁöÑloading

    try {
      uni.showLoading({
        title,
        mask: true,
        complete: () => {
          this._isLoading = true;
          this._currentTitle = title;
          console.log(`[BLE-Loading] ÊòæÁ§∫: ${title}`);
          
          // ËÆæÁΩÆË∂ÖÊó∂Ëá™Âä®ÈöêËóè
          if (this._loadingTimer) {
            clearTimeout(this._loadingTimer);
          }
          this._loadingTimer = setTimeout(() => {
            console.warn(`[BLE-Loading] Ë∂ÖÊó∂Ëá™Âä®ÈöêËóè: ${title}`);
            this.hide();
          }, 15000);
        }
      });
    } catch (error) {
      console.warn('[BLE-Loading] ÊòæÁ§∫Â§±Ë¥•:', error);
      this._isLoading = false;
      this._currentTitle = '';
    }
  }

  hide(): void {
    if (this._isLoading) {
      try {
        uni.hideLoading();
        console.log(`[BLE-Loading] ÈöêËóè: ${this._currentTitle}`);
      } catch (error) {
        console.warn('[BLE-Loading] ÈöêËóèÂ§±Ë¥•:', error);
      }
    }
    
    this._isLoading = false;
    this._currentTitle = '';
    
    if (this._loadingTimer) {
      clearTimeout(this._loadingTimer);
      this._loadingTimer = null;
    }
  }

  isLoading(): boolean {
    return this._isLoading;
  }

  getCurrentTitle(): string {
    return this._currentTitle;
  }
}

// ÂÖ®Â±ÄÂèòÈáè
let _loading = false;
const loadingManager = LoadingManager.getInstance();

// Á±ªÂûãÂÆö‰πâ
interface ApiOptions {
  success?: (res: any) => void;
  fail?: (res: any) => void;
  complete?: () => void;
  [key: string]: any;
}

interface ApiResponse {
  data: any;
  status: 'success' | 'fail';
}

interface ChargeDeviceInfo {
  PRE?: string;
  VID: string;
  ID: number;
  MYVID: string;
  STATUS?: number;
  ORDERID?: number;
  REMAINTIME?: number;
  REMAINSHOW?: string;
  REMAINQUANTITY?: number;
  USEQUANTITY?: number;
  CHECK: string;
  UUID?: string;
}

interface BluetoothDevice {
  deviceId: string;
  name?: string;
  RSSI?: number;
  advertisData?: ArrayBuffer;
  advertisServiceUUIDs?: string[];
  localName?: string;
  serviceData?: any;
}

interface DetailedDeviceStatus {
  isOnline: boolean;
  deviceId: number;
  deviceInfo?: ChargeDeviceInfo;
  signalStrength?: number;
  bluetoothDeviceId?: string;
  status?: {
    code: number;
    text: string;
  };
  remainInfo?: {
    time: number;
    timeDisplay: string;
    quantity: number;
  };
  orderInfo?: {
    orderId: number;
    isActive: boolean;
  };
  batteryInfo?: {
    usedQuantity: number;
    remainQuantity: number;
  };
  connectionInfo?: {
    rssi: number;
    signalLevel: 'excellent' | 'good' | 'fair' | 'poor';
  };
  errorInfo?: {
    hasError: boolean;
    errorMessage?: string;
  };
}

/**
 * Â∞ÅË£Öuni API‰∏∫Promise
 */
function $uni(api: string, opts: ApiOptions = {}): Promise<ApiResponse> {
  return new Promise(resolve => {
    (uni as any)[api](Object.assign({}, opts, {
      success: (res: any) => resolve({ data: res, status: 'success' }),
      fail: (res: any) => resolve({ data: res, status: 'fail' })
    }));
  });
}

/**
 * ÊòæÁ§∫Âä†ËΩΩÊèêÁ§∫
 */
function showLoading(title: string = 'Âä†ËΩΩ‰∏≠'): void {
  loadingManager.show(title);
}

/**
 * ÈöêËóèÂä†ËΩΩÊèêÁ§∫
 */
function hideLoading(): void {
  loadingManager.hide();
}

/**
 * ÈªòËÆ§Â§±Ë¥•ÂõûË∞É
 */
function failCallback(): void {
  uni.showToast({ title: 'ËØ∑Ê±ÇÈîôËØØ' });
}

/**
 * Âà§Êñ≠ÊòØÂê¶‰∏∫ÂáΩÊï∞
 */
function isFunction(val: any): val is Function {
  return typeof val === 'function';
}

/**
 * POSTËØ∑Ê±ÇÂ∞ÅË£Ö
 */
function postData(
  url: string,
  data: any,
  successCallback?: (data: any) => void,
  failCallback?: () => void
): Promise<any> {
  showLoading('ËØ∑Ê±Ç‰∏≠...');
  return new Promise((resolve, reject) => {
    uni.request({
      url: url,
      method: 'POST',
      data: data,
      header: { 'Content-Type': 'application/json' },
      success: (res) => {
        isFunction(successCallback) && successCallback(res.data);
        hideLoading();
        return resolve(res.data);
      },
      fail: (res) => {
        isFunction(failCallback) && failCallback();
        hideLoading();
        return reject(res);
      }
    });
  });
}

/**
 * Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂÖÖÁîµËÆæÂ§á
 */
function isChargeDevice(view: Uint8Array): ChargeDeviceInfo | undefined {
  let CHECK: string;
  const PRE = byteChar2String([view[0]]);
  const VID = byteChar2String([view[5], view[6], view[7], view[8]]);
  const MYVID = byteChar2String([view[8], view[9], view[10]]);

  if (VID === '002C' || VID === '003C') {
    const ID = hex2Int(int2Hex(view[11]) + '' + int2Hex(view[12]) + '' + int2Hex(view[13]));

    if (Number(ID) === 0) {
      const UUID = byteChar2String([view[14], view[15], view[16], view[17], view[18], view[19], view[20], view[21]]);
      CHECK = int2Hex(view[25]) + '' + int2Hex(view[26]) + '' + int2Hex(view[27]) + '' + int2Hex(view[28]);

      return { VID: VID, ID: ID, MYVID: MYVID, UUID: UUID, CHECK: CHECK };
    } else {
      const STATUS = hex2Int(int2Hex(view[14]));
      const ORDERID = hex2Int(int2Hex(view[15]) + '' + int2Hex(view[16]) + '' + int2Hex(view[17]) + '' + int2Hex(view[18]));
      let REMAINTIME = 0;
      let REMAINQUANTITY = 0;
      let REMAINSHOW = '';

      if (Number(view[19]) === 255 && Number(view[20]) === 255 && Number(view[21]) === 255) {
        // FFFFFFÔºåÊóßÂõ∫‰ª∂ËøîÂõû-1
        REMAINTIME = 0;
        REMAINQUANTITY = 0;
      } else {
        if (view[19] / 128 >= 1) { // Ââ©‰ΩôÁîµÈáè
          REMAINQUANTITY = hex2Int(int2Hex(view[19] % 128) + '' + int2Hex(view[20]) + '' + int2Hex(view[21]));
        } else { // Ââ©‰ΩôÊó∂Èïø
          REMAINTIME = hex2Int(int2Hex(view[19]) + '' + int2Hex(view[20]) + '' + int2Hex(view[21]));
          // Ââ©‰ΩôÊó∂Èó¥Ë∂ÖËøá‰∏ÄÂÆöÂÄºÔºåÂàôÊåâÂ§©ËøõË°åÊ†∏ÁÆó
          if (REMAINTIME >= 8323072) REMAINTIME = (REMAINTIME - 8323072) * 3600 * 24;

          let MYTIME = REMAINTIME;
          if (MYTIME > 86400) {
            const day = Math.floor(MYTIME / 86400);
            MYTIME -= day * 86400;
            REMAINSHOW += day + 'Â§©';
          }
          if (MYTIME > 3600) {
            const hour = Math.floor(MYTIME / 3600);
            MYTIME -= hour * 3600;
            REMAINSHOW += hour + 'Â∞èÊó∂';
          }
          if (MYTIME > 60) {
            const minute = Math.floor(MYTIME / 60);
            MYTIME -= minute * 60;
            REMAINSHOW += minute + 'ÂàÜÈíü';
          }
          if (MYTIME > 0) {
            REMAINSHOW += MYTIME + 'Áßí';
          }
        }
      }

      const USEQUANTITY = hex2Int(int2Hex(view[22]) + '' + int2Hex(view[23]) + '' + int2Hex(view[24]));
      CHECK = int2Hex(view[25]) + '' + int2Hex(view[26]) + '' + int2Hex(view[27]) + '' + int2Hex(view[28]);

      return {
        PRE,
        VID,
        ID,
        MYVID,
        STATUS,
        ORDERID,
        REMAINTIME,
        REMAINSHOW,
        REMAINQUANTITY,
        USEQUANTITY,
        CHECK
      };
    }
  }
  return undefined;
}

/**
 * Ëé∑ÂèñÊï∞ÊçÆArrayBufferÊï∞ÁªÑ
 */
function getDataArrayBuffer(dataString: string): ArrayBuffer[] {
  let data: string;
  const arr: ArrayBuffer[] = [];

  while (dataString.length > 40) {
    data = dataString.substring(0, 40);
    const buffer = new ArrayBuffer(20);
    const dataView = new DataView(buffer);
    for (let i = 0; i < 20; i++) {
      dataView.setUint8(i, parseInt(data.substring(i * 2, i * 2 + 2), 16));
    }
    arr.push(buffer);
    dataString = dataString.substring(40, dataString.length);
  }

  data = dataString;
  const buffer = new ArrayBuffer(data.length / 2);
  const dataView = new DataView(buffer);

  for (let i = 0; i < data.length / 2; i++) {
    dataView.setUint8(i, parseInt(data.substring(i * 2, i * 2 + 2), 16));
  }
  arr.push(buffer);
  return arr;
}

/**
 * Ê£ÄÊü•ËìùÁâôÊùÉÈôê
 */
function checkBluetooth(): Promise<boolean> {
  return new Promise((resolve, reject) => {
    uni.getSetting({
      success: (res) => {
        const authSetting = res.authSetting as any;

        if (typeof authSetting['scope.bluetooth'] === 'undefined') {
          uni.authorize({
            scope: 'scope.bluetooth',
            complete() {
              uni.showModal({
                content: 'ËìùÁâôÊéàÊùÉÂêéÈáçËØï',
                showCancel: false,
                confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
              });
              reject(false);
            }
          });
        }
        if (authSetting['scope.bluetooth'] === false) {
          uni.openSetting({
            success: () => {
              uni.showModal({
                content: 'ËìùÁâôÊéàÊùÉÂêéÈáçËØï',
                showCancel: false,
                confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
              });
              reject(false);
            }
          });
        }
        if (authSetting['scope.bluetooth'] === true) {
          resolve(true);
        }
      },
      fail: () => reject(false)
    });
  });
}

/**
 * ËÆæÂ§áÁä∂ÊÄÅÁ†ÅÊò†Â∞Ñ
 */
const DEVICE_STATUS_MAP: Record<number, string> = {
  0: 'ÈÄöÁîµÂÅúÊ≠¢',
  1: 'ÂêØÂä®‰∏≠',
  2: 'ÊãîÊèíÊñ≠Áîµ',
  3: 'ËøáËΩΩÊñ≠Áîµ',
  4: 'Áü≠Ë∑ØÊñ≠Áîµ',
  5: 'ÂÖÖÊª°Êñ≠Áîµ',
  6: '‰∏ªÂä®Êñ≠Áîµ',
  10: 'ÁîµÊ±†ÁîµÂéã‰Ωé',
  30: 'ÁÆ°ÁêÜÂëòÂÅúÁî®',
  31: 'Â∫ìÂ≠òÁî®ÂÆå',
  50: 'Ê∑πÊ∞¥ÊïÖÈöú'
};

/**
 * Ê†πÊçÆ‰ø°Âè∑Âº∫Â∫¶ËØÑ‰º∞‰ø°Âè∑Á≠âÁ∫ß
 */
function getSignalLevel(rssi: number): 'excellent' | 'good' | 'fair' | 'poor' {
  if (rssi >= -40) return 'excellent';
  if (rssi >= -55) return 'good';
  if (rssi >= -70) return 'fair';
  return 'poor';
}

/**
 * Ê£ÄÊü•ËÆæÂ§áËØ¶ÁªÜÁä∂ÊÄÅÔºàÊñ∞Â¢ûÊñπÊ≥ïÔºâ
 * @param deviceId ËÆæÂ§áID
 * @returns ËØ¶ÁªÜÁöÑËÆæÂ§áÁä∂ÊÄÅ‰ø°ÊÅØ
 */
async function checkDetailedDeviceStatus(deviceId: number): Promise<DetailedDeviceStatus> {
  try {
    console.log(`[BLE] üöÄ ÂºÄÂßãÊ£ÄÊµãËÆæÂ§á ${deviceId} ÁöÑËØ¶ÁªÜÁä∂ÊÄÅ`);

    // #ifdef MP-WEIXIN
    const hasPermission = await checkBluetooth().catch(_ => false);
    if (!hasPermission) {
      console.log('[BLE] ‚ùå ËìùÁâôÊùÉÈôêÊ£ÄÊü•Â§±Ë¥•');
      return {
        isOnline: false,
        deviceId,
        errorInfo: {
          hasError: true,
          errorMessage: 'ËìùÁâôÊùÉÈôêÊú™ÊéàÊùÉ'
        }
      };
    }
    // #endif

    return new Promise((resolve) => {
      showLoading('Ê≠£Âú®Ê£ÄÊµãËÆæÂ§áÁä∂ÊÄÅ...');
      let myDevice: BluetoothDevice | null = null;
      let deviceInfo: ChargeDeviceInfo | null = null;
      let tryCnt = 0;
      let isFound = false;
      let searchTimer: any = null;

      // ËÆæÁΩÆÊêúÁ¥¢Ë∂ÖÊó∂Ôºà‰ºòÂåñÂà∞10ÁßíÔºåÁªôËØ¶ÁªÜÊ£ÄÊµãÊõ¥Â§öÊó∂Èó¥Ôºâ
      const searchTimeout = setTimeout(() => {
        console.log('[BLE] ‚è∞ ÊêúÁ¥¢Ë∂ÖÊó∂ÔºåÂÅúÊ≠¢ÊêúÁ¥¢');
        cleanup();
        resolve({
          isOnline: false,
          deviceId,
          errorInfo: {
            hasError: true,
            errorMessage: 'ÊêúÁ¥¢Ë∂ÖÊó∂ÔºåËÆæÂ§áÂèØËÉΩÁ¶ªÁ∫ø'
          }
        });
      }, 10000);

      const cleanup = () => {
        if (searchTimer) {
          clearTimeout(searchTimer);
          searchTimer = null;
        }
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        uni.stopBluetoothDevicesDiscovery();
        uni.offBluetoothDeviceFound();
        hideLoading();
      };

      uni.openBluetoothAdapter({
        success: () => {
          console.log('[BLE] ‚úÖ ËìùÁâôÈÄÇÈÖçÂô®ÂàùÂßãÂåñÊàêÂäü');
          uni.startBluetoothDevicesDiscovery({
            allowDuplicatesKey: true,
            interval: 50,
            complete: () => {
              console.log('[BLE] üîç ÂºÄÂßãÊêúÁ¥¢ËÆæÂ§á');

              uni.onBluetoothDeviceFound((res: any) => {
                tryCnt++;
                if (tryCnt % 20 === 0) {
                  showLoading(`Ê£ÄÊµãËÆæÂ§áÁä∂ÊÄÅ(${Math.floor(tryCnt / 20)})...`);
                }

                const devices: BluetoothDevice[] = res.devices;
                for (let i = 0; i < devices.length; i++) {
                  if (devices[i].advertisData) {
                    try {
                      const view = new Uint8Array(devices[i].advertisData as ArrayBuffer);
                      const checkDevice = isChargeDevice(view);
                      if (checkDevice && Number(checkDevice.ID) === Number(deviceId)) {
                        myDevice = devices[i];
                        deviceInfo = checkDevice;
                        isFound = true;
                        console.log(`[BLE] üéØ ÊâæÂà∞ÁõÆÊ†áËÆæÂ§á ${deviceId}ÔºåÊêúÁ¥¢Ê¨°Êï∞: ${tryCnt}`);

                        // ÊûÑÂª∫ËØ¶ÁªÜÁä∂ÊÄÅ‰ø°ÊÅØ
                        const detailedStatus: DetailedDeviceStatus = {
                          isOnline: true,
                          deviceId,
                          deviceInfo: checkDevice,
                          signalStrength: devices[i].RSSI,
                          bluetoothDeviceId: devices[i].deviceId,
                          status: checkDevice.STATUS !== undefined ? {
                            code: checkDevice.STATUS,
                            text: DEVICE_STATUS_MAP[checkDevice.STATUS] || `Êú™Áü•Áä∂ÊÄÅ(${checkDevice.STATUS})`
                          } : undefined,
                          remainInfo: {
                            time: checkDevice.REMAINTIME || 0,
                            timeDisplay: checkDevice.REMAINSHOW || 'Êó†',
                            quantity: checkDevice.REMAINQUANTITY || 0
                          },
                          orderInfo: checkDevice.ORDERID !== undefined ? {
                            orderId: checkDevice.ORDERID,
                            isActive: checkDevice.ORDERID > 0
                          } : undefined,
                          batteryInfo: {
                            usedQuantity: checkDevice.USEQUANTITY || 0,
                            remainQuantity: checkDevice.REMAINQUANTITY || 0
                          },
                          connectionInfo: devices[i].RSSI !== undefined ? {
                            rssi: devices[i].RSSI!,
                            signalLevel: getSignalLevel(devices[i].RSSI!)
                          } : undefined,
                          errorInfo: {
                            hasError: false
                          }
                        };

                        // Á´ãÂç≥ÂÅúÊ≠¢ÊêúÁ¥¢Âπ∂ËøîÂõûÁªìÊûú
                        cleanup();
                        resolve(detailedStatus);
                        return;
                      }
                    } catch (error) {
                      console.warn('[BLE] ËÆæÂ§áÊï∞ÊçÆËß£ÊûêÈîôËØØÔºåË∑≥Ëøá:', error);
                    }
                  }
                }

                // Â¶ÇÊûúÊêúÁ¥¢Ê¨°Êï∞ËææÂà∞ÈôêÂà∂‰∏îÊú™ÊâæÂà∞ËÆæÂ§áÔºåËøîÂõûÂ§±Ë¥•
                if (tryCnt >= 200 && !isFound) {
                  console.log('[BLE] ‚ùå ÊêúÁ¥¢Ê¨°Êï∞ËææÂà∞ÈôêÂà∂ÔºåÊú™ÊâæÂà∞ËÆæÂ§á');
                  cleanup();
                  resolve({
                    isOnline: false,
                    deviceId,
                    errorInfo: {
                      hasError: true,
                      errorMessage: 'ËÆæÂ§áÁ¶ªÁ∫øÊàñ‰∏çÂú®ÈôÑËøë'
                    }
                  });
                }
              });
            }
          });
        },
        fail: (error: any) => {
          console.error('[BLE] ‚ùå ËìùÁâôÈÄÇÈÖçÂô®ÂàùÂßãÂåñÂ§±Ë¥•:', error);
          cleanup();

          let message = 'ËìùÁâôÂêØÂä®Â§±Ë¥•ÔºåËØ∑ÂºÄÂêØÈáçËØï';
          if (error.errCode === 10001) {
            message = 'ËìùÁâôÊú™ÂºÄÂêØÔºåËØ∑Âú®ËÆæÁΩÆ‰∏≠ÂºÄÂêØËìùÁâôÂêéÈáçËØï';
          }

          resolve({
            isOnline: false,
            deviceId,
            errorInfo: {
              hasError: true,
              errorMessage: message
            }
          });
        }
      });
    });
  } catch (error) {
    console.error('[BLE] ‚ùå Ê£ÄÊü•ËÆæÂ§áËØ¶ÁªÜÁä∂ÊÄÅÂ§±Ë¥•:', error);
    hideLoading();
    return {
      isOnline: false,
      deviceId,
      errorInfo: {
        hasError: true,
        errorMessage: 'Ê£ÄÊµãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï'
      }
    };
  }
}

/**
 * Ê£ÄÊü•ËÆæÂ§áÊòØÂê¶Âú®Á∫øÔºà‰ºòÂåñÁâàÊú¨Ôºâ
 */
async function checkDeviceOnline(deviceId: number): Promise<boolean> {
  try {
    console.log(`[BLE] üöÄ ÂºÄÂßãÊ£ÄÊµãËÆæÂ§á ${deviceId} ÊòØÂê¶Âú®Á∫ø`);

    // #ifdef MP-WEIXIN
    const hasPermission = await checkBluetooth().catch(_ => false);
    if (!hasPermission) {
      console.log('[BLE] ‚ùå ËìùÁâôÊùÉÈôêÊ£ÄÊü•Â§±Ë¥•');
      return false;
    }
    // #endif

    return new Promise((resolve) => {
      showLoading('Âø´ÈÄüÊêúÁ¥¢ËÆæÂ§á...');
      let myDevice: BluetoothDevice | null = null;
      let tryCnt = 0;
      let isFound = false;
      let searchTimer: any = null;

      // ËÆæÁΩÆÊêúÁ¥¢Ë∂ÖÊó∂Ôºà‰ºòÂåñÂà∞8ÁßíÔºâ
      const searchTimeout = setTimeout(() => {
        console.log('[BLE] ‚è∞ ÊêúÁ¥¢Ë∂ÖÊó∂ÔºåÂÅúÊ≠¢ÊêúÁ¥¢');
        cleanup();
        resolve(false);
      }, 8000);

      const cleanup = () => {
        if (searchTimer) {
          clearTimeout(searchTimer);
          searchTimer = null;
        }
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        uni.stopBluetoothDevicesDiscovery();
        uni.offBluetoothDeviceFound();
        hideLoading();
      };

      uni.openBluetoothAdapter({
        success: () => {
          console.log('[BLE] ‚úÖ ËìùÁâôÈÄÇÈÖçÂô®ÂàùÂßãÂåñÊàêÂäü');
          uni.startBluetoothDevicesDiscovery({
            allowDuplicatesKey: true,
            interval: 50, // ‰ºòÂåñÊêúÁ¥¢Èó¥ÈöîÂà∞50ms
            complete: () => {
              console.log('[BLE] üîç ÂºÄÂßãÊêúÁ¥¢ËÆæÂ§á');

              uni.onBluetoothDeviceFound((res: any) => {
                tryCnt++;
                if (tryCnt % 10 === 0) { // ÂáèÂ∞ëUIÊõ¥Êñ∞È¢ëÁéá
                  showLoading(`Âø´ÈÄüÊêúÁ¥¢(${Math.floor(tryCnt / 10)})...`);
                }

                const devices: BluetoothDevice[] = res.devices;
                for (let i = 0; i < devices.length; i++) {
                  
                  console.log('devices[i].advertisData', devices[i].advertisData);
                  if (devices[i].advertisData) {
                    try {
                      const view = new Uint8Array(devices[i].advertisData as ArrayBuffer);
                      const checkDevice = isChargeDevice(view);
                      if (checkDevice && Number(checkDevice.ID) === Number(deviceId)) {
                        myDevice = devices[i];
                        isFound = true;
                        console.log(`[BLE] üéØ ÊâæÂà∞ÁõÆÊ†áËÆæÂ§á ${deviceId}ÔºåÊêúÁ¥¢Ê¨°Êï∞: ${tryCnt}`);

                        // Á´ãÂç≥ÂÅúÊ≠¢ÊêúÁ¥¢Âπ∂ËøîÂõûÁªìÊûú
                        cleanup();
                        resolve(true);
                        return;
                      }
                    } catch (error) {
                      // ÂøΩÁï•Ëß£ÊûêÈîôËØØÔºåÁªßÁª≠ÊêúÁ¥¢
                      console.warn('[BLE] ËÆæÂ§áÊï∞ÊçÆËß£ÊûêÈîôËØØÔºåË∑≥Ëøá:', error);
                    }
                  }
                }

                // Â¶ÇÊûúÊêúÁ¥¢Ê¨°Êï∞ËææÂà∞ÈôêÂà∂‰∏îÊú™ÊâæÂà∞ËÆæÂ§áÔºåËøîÂõûÂ§±Ë¥•
                if (tryCnt >= 100 && !isFound) {
                  console.log('[BLE] ‚ùå ÊêúÁ¥¢Ê¨°Êï∞ËææÂà∞ÈôêÂà∂ÔºåÊú™ÊâæÂà∞ËÆæÂ§á');
                  cleanup();
                  resolve(false);
                }
              });
            }
          });
        },
        fail: (error: any) => {
          console.error('[BLE] ‚ùå ËìùÁâôÈÄÇÈÖçÂô®ÂàùÂßãÂåñÂ§±Ë¥•:', error);
          cleanup();

          let message = 'ËìùÁâôÂêØÂä®Â§±Ë¥•ÔºåËØ∑ÂºÄÂêØÈáçËØï';
          if (error.errCode === 10001) {
            message = 'ËìùÁâôÊú™ÂºÄÂêØÔºåËØ∑Âú®ËÆæÁΩÆ‰∏≠ÂºÄÂêØËìùÁâôÂêéÈáçËØï';
          }

          uni.showModal({
            content: message,
            showCancel: false,
            confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
          });
          resolve(false);
        }
      });
    });
  } catch (error) {
    console.error('[BLE] ‚ùå Ê£ÄÊü•ËÆæÂ§áÂú®Á∫øÁä∂ÊÄÅÂ§±Ë¥•:', error);
    hideLoading();
    return false;
  }
}

/**
 * ÂÜôÂÖ•ÂÖÖÁîµÊï∞ÊçÆÔºà‰ºòÂåñÁâàÊú¨Ôºâ
 */
async function writeChargeData(deviceId: number, CMD: string): Promise<void> {
  try {
    console.log(`[BLE] üöÄ ÂºÄÂßãÂÜôÂÖ•ÂÖÖÁîµÊï∞ÊçÆÂà∞ËÆæÂ§á ${deviceId}`);
    console.log('CMD', CMD)
    
    // È™åËØÅCMDÊåá‰ª§Ê†ºÂºè
    if (!CMD || CMD.length < 20) {
      throw new Error('ÊéßÂà∂Êåá‰ª§Ê†ºÂºèÈîôËØØÔºåËØ∑ÈáçÊñ∞Ëé∑ÂèñÊåá‰ª§');
    }
    
    // #ifdef MP-WEIXIN
    const hasPermission = await checkBluetooth().catch(_ => false);
    if (!hasPermission) { return; }
    // #endif

    showLoading('ÂáÜÂ§áËøûÊé•...');
    let myDevice: BluetoothDevice | null = null;
    let tryCnt = 0;
    let isFound = false;

    uni.openBluetoothAdapter({
      success: () => {
        uni.startBluetoothDevicesDiscovery({
          allowDuplicatesKey: true,
          interval: 50, // ‰ºòÂåñÊêúÁ¥¢Èó¥Èöî
          complete: () => {
            showLoading('Âø´ÈÄüÊêúÁ¥¢ËÆæÂ§á...');

            uni.onBluetoothDeviceFound((res: any) => {
              showLoading(`Âø´ÈÄüÊêúÁ¥¢(${tryCnt})...`);
              const devices: BluetoothDevice[] = res.devices;

              for (let i = 0; i < devices.length; i++) {
                if (devices[i].advertisData) {
                  try {
                    const view = new Uint8Array(devices[i].advertisData as ArrayBuffer);
                    const checkDevice = isChargeDevice(view);
                    if (checkDevice && Number(checkDevice.ID) === Number(deviceId)) {
                      myDevice = devices[i];
                      if (isFound) tryCnt = 0;
                      else tryCnt = 100;
                      isFound = true;
                      break;
                    }
                  } catch (error) {
                    console.warn('[BLE] ËÆæÂ§áÊï∞ÊçÆËß£ÊûêÈîôËØØÔºåË∑≥Ëøá:', error);
                  }
                }
              }

              if (tryCnt >= 20) {
                tryCnt = 0;
                uni.stopBluetoothDevicesDiscovery({
                  fail: (res: any) => {
                    failWrite(myDevice, res.errCode, res.errMsg);
                  },
                  success: () => {
                    if (myDevice) {
                      showLoading('Âø´ÈÄüËøûÊé•ËÆæÂ§á...');
                      uni.createBLEConnection({
                        deviceId: myDevice.deviceId,
                        fail: (res: any) => {
                          failWrite(myDevice, res.errCode, res.errMsg);
                        },
                        success: async () => {
                          showLoading('ËøûÊé•ËÆæÂ§á...');
                          const serviceId = '00000001-0000-1000-8000-00805F9B34FB';
                          const wcharacteristicId = '00000003-0000-1000-8000-00805F9B34FB';
                          let successNum = 0;
                          let failNum = 0;
                          let hasService = false;
                          let nowTime = 0;
                          let diffTime = 0;
                          const startTime = Date.now();

                          // ‰ºòÂåñÊúçÂä°ÂèëÁé∞Á≠âÂæÖÊó∂Èó¥Ôºà‰ªé10Áßí‰ºòÂåñÂà∞5ÁßíÔºâ
                          while (nowTime - startTime < 10000) {
                            nowTime = Date.now();
                            if (nowTime - diffTime < 10000) { continue; } // ‰ºòÂåñÈáçËØïÈó¥ÈöîÂà∞200ms

                            const res = await $uni('getBLEDeviceServices', { deviceId: myDevice!.deviceId });
                            if (res.status === 'fail') {
                              failWrite(myDevice, res.data.errCode, res.data.errMsg);
                              break;
                            }
                            if (res.status === 'success' && res.data.services.length > 0) {
                              hasService = true;
                              break;
                            }
                            diffTime = nowTime;
                          }

                          if (!hasService) {
                            failWrite(myDevice, -1, 'ÊúçÂä°ÂèëÁé∞Ë∂ÖÊó∂');
                            return;
                          }

                          showLoading('Ëé∑ÂèñËÆæÂ§áÁâπÂæÅ...');
                          uni.getBLEDeviceCharacteristics({
                            deviceId: myDevice!.deviceId,
                            serviceId,
                            fail: (res: any) => {
                              failWrite(myDevice, res.errCode, res.errMsg);
                            },
                            success: () => {
                              showLoading('ÂèëÈÄÅÊåá‰ª§...');
                              const dataArr = getDataArrayBuffer(CMD);

                              for (let i = 0; i < dataArr.length; i++) {
                                const data = dataArr[i];
                                console.log('ÂèëÈÄÅÊï∞ÊçÆ: ', data);
                                
                                uni.writeBLECharacteristicValue({
                                  deviceId: myDevice!.deviceId,
                                  serviceId,
                                  characteristicId: wcharacteristicId,
                                  value: data as any,
                                  success: () => {
                                    successNum++;
                                    console.log(`[BLE] Êï∞ÊçÆÂåÖ ${i+1}/${dataArr.length} ÂèëÈÄÅÊàêÂäü`);
                                  },
                                  fail: (res: any) => {
                                    failNum++;
                                    console.error(`[BLE] Êï∞ÊçÆÂåÖ ${i+1} ÂèëÈÄÅÂ§±Ë¥•:`, res);
                                    failWrite(myDevice, res.errCode, res.errMsg);
                                  },
                                  complete: () => {
                                    if (successNum === dataArr.length) {
                                      console.log(`[BLE] ÊâÄÊúâÊï∞ÊçÆÂåÖÂèëÈÄÅÂÆåÊàêÔºåÊàêÂäü: ${successNum}, Â§±Ë¥•: ${failNum}`);
                                      // Âª∂Êó∂È™åËØÅËÆæÂ§áÁä∂ÊÄÅ
                                      setTimeout(() => {
                                        verifyDeviceStatus(myDevice, deviceId);
                                      }, 2000);
                                    }
                                  }
                                })

                                if (failNum > 0) { break; }
                                sleep(100); // ‰ºòÂåñÂèëÈÄÅÈó¥ÈöîÂà∞50ms
                              }
                            }
                          });
                        }
                      });
                    } else {
                      hideLoading();
                      uni.showModal({
                        content: 'Êú™Ê£ÄÊµãÂà∞ÂØπÂ∫îÈÄöÁîµËÆæÂ§áÔºåËØ∑ÈáçËØï',
                        showCancel: false,
                        confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
                      });
                      uni.closeBluetoothAdapter({ complete: _ => null });
                    }
                  }
                });
              }
              tryCnt++;
            });
          }
        });
      },
      fail: (error: any) => {
        hideLoading();
        let message = 'ËìùÁâôÂêØÂä®Â§±Ë¥•ÔºåËØ∑ÂºÄÂêØÈáçËØï';
        if (error.errCode === 10001) {
          message = 'ËìùÁâôÊú™ÂºÄÂêØÔºåËØ∑Âú®ËÆæÁΩÆ‰∏≠ÂºÄÂêØËìùÁâôÂêéÈáçËØï';
        }
        uni.showModal({
          content: message,
          showCancel: false,
          confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
        });
      }
    });
  } catch (error) {
    console.error('[BLE] ‚ùå ÂÜôÂÖ•ÂÖÖÁîµÊï∞ÊçÆÂ§±Ë¥•:', error);
    hideLoading();
    uni.showModal({
      content: 'Êìç‰ΩúÂ§±Ë¥•ÔºåËØ∑ÈáçËØï',
      showCancel: false,
      confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
    });
  }
}

/**
 * È™åËØÅËÆæÂ§áÁä∂ÊÄÅ
 */
async function verifyDeviceStatus(myDevice: BluetoothDevice | null, deviceId: number): Promise<void> {
  try {
    console.log(`[BLE] üîç È™åËØÅËÆæÂ§á ${deviceId} Áä∂ÊÄÅ...`);
    
    // ÈáçÊñ∞Ê£ÄÊü•ËÆæÂ§áÁä∂ÊÄÅ
    const isOnline = await checkDeviceOnline(deviceId);
    if (!isOnline) {
      console.log('[BLE] ‚ö†Ô∏è ËÆæÂ§áÂ∑≤Á¶ªÁ∫øÔºåÂèØËÉΩÂ∑≤ÂêØÂä®');
      successWrite(myDevice);
      return;
    }
    
    // ËÆæÂ§á‰ªçÂú®Á∫øÔºåÊ£ÄÊü•ÊòØÂê¶ÊúâÁä∂ÊÄÅÂèòÂåñ
    showLoading('È™åËØÅËÆæÂ§áÁä∂ÊÄÅ...');
    
    uni.openBluetoothAdapter({
      success: () => {
        uni.startBluetoothDevicesDiscovery({
          allowDuplicatesKey: true,
          interval: 100,
          complete: () => {
            let checkCount = 0;
            const maxChecks = 5;
            
            const deviceFoundHandler = (res: any) => {
              checkCount++;
              const devices: BluetoothDevice[] = res.devices;
              
              for (let i = 0; i < devices.length; i++) {
                if (devices[i].advertisData) {
                  try {
                    const view = new Uint8Array(devices[i].advertisData as ArrayBuffer);
                    const checkDevice = isChargeDevice(view);
                    
                    if (checkDevice && Number(checkDevice.ID) === Number(deviceId)) {
                      console.log(`[BLE] ËÆæÂ§áÁä∂ÊÄÅÊ£ÄÊü• ${checkCount}/${maxChecks}:`, checkDevice);
                      
                      // Ê£ÄÊü•ËÆæÂ§áÊòØÂê¶Âú®Â∑•‰ΩúÁä∂ÊÄÅ
                      if (checkDevice.STATUS && checkDevice.STATUS > 0) {
                        console.log('[BLE] ‚úÖ ËÆæÂ§áÂ∑≤ÂêØÂä®ÔºåÁä∂ÊÄÅÊ≠£Â∏∏');
                        cleanup();
                        successWrite(myDevice);
                        return;
                      }
                    }
                  } catch (error) {
                    console.warn('[BLE] ËÆæÂ§áÁä∂ÊÄÅËß£ÊûêÈîôËØØ:', error);
                  }
                }
              }
              
              if (checkCount >= maxChecks) {
                console.log('[BLE] ‚ö†Ô∏è ËÆæÂ§áÁä∂ÊÄÅÊ£ÄÊü•ÂÆåÊàêÔºåÊú™Ê£ÄÊµãÂà∞ÂêØÂä®Áä∂ÊÄÅ');
                cleanup();
                // ÊòæÁ§∫ÂèØËÉΩÁöÑÈóÆÈ¢òÊèêÁ§∫
                uni.showModal({
                  title: 'ËÆæÂ§áÁä∂ÊÄÅÊèêÈÜí',
                  content: 'Êåá‰ª§Â∑≤ÂèëÈÄÅÔºå‰ΩÜËÆæÂ§áÂèØËÉΩÊú™ÂêØÂä®„ÄÇ\nÂèØËÉΩÂéüÂõ†Ôºö\n1. ËÆæÂ§áÂøôÁ¢åÊàñÊïÖÈöú\n2. ÊéßÂà∂Êåá‰ª§ËøáÊúü\n3. ËÆæÂ§áÈúÄË¶ÅÊâãÂä®ÈáçÂêØ\n\nËØ∑Ê£ÄÊü•ËÆæÂ§áÁä∂ÊÄÅÊàñËÅîÁ≥ªÂÆ¢Êúç„ÄÇ',
                  showCancel: true,
                  cancelText: 'ÊàëÁü•ÈÅì‰∫Ü',
                  confirmText: 'ÈáçËØïÊéßÂà∂',
                  success: (res) => {
                    if (res.confirm) {
                      // ÈáçËØïÊéßÂà∂ÈÄªËæëÂèØ‰ª•Âú®‰∏äÂ±ÇÂ§ÑÁêÜ
                      console.log('[BLE] Áî®Êà∑ÈÄâÊã©ÈáçËØïÊéßÂà∂');
                    }
                  }
                });
                
                if (myDevice) {
                  uni.closeBLEConnection({
                    deviceId: myDevice.deviceId,
                    complete: _ => null
                  });
                }
                uni.closeBluetoothAdapter({ complete: _ => null });
              }
            };
            
            const cleanup = () => {
              uni.stopBluetoothDevicesDiscovery();
              uni.offBluetoothDeviceFound(deviceFoundHandler);
              hideLoading();
            };
            
            uni.onBluetoothDeviceFound(deviceFoundHandler);
            
            // ËÆæÁΩÆË∂ÖÊó∂
            setTimeout(() => {
              if (checkCount < maxChecks) {
                console.log('[BLE] ‚è∞ ËÆæÂ§áÁä∂ÊÄÅÊ£ÄÊü•Ë∂ÖÊó∂');
                cleanup();
                successWrite(myDevice);
              }
            }, 8000);
          }
        });
      },
      fail: () => {
        console.log('[BLE] ‚ùå ËÆæÂ§áÁä∂ÊÄÅÈ™åËØÅÂ§±Ë¥•');
        successWrite(myDevice);
      }
    });
    
  } catch (error) {
    console.error('[BLE] ‚ùå ËÆæÂ§áÁä∂ÊÄÅÈ™åËØÅÂºÇÂ∏∏:', error);
    successWrite(myDevice);
  }
}

/**
 * ÂÜôÂÖ•ÊàêÂäüÂõûË∞É
 */
function successWrite(myDevice: BluetoothDevice | null): void {
  hideLoading();
  uni.showModal({
    content: 'Êåá‰ª§ÂèëÈÄÅÊàêÂäüÔºåËØ∑Á®çÂÄôËßÇÂØüËÆæÂ§áÊòØÂê¶ÂêØÂä®',
    showCancel: false,
    confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
  });
  if (myDevice) {
    uni.closeBLEConnection({
      deviceId: myDevice.deviceId,
      complete: _ => null
    });
  }
  uni.closeBluetoothAdapter({ complete: _ => null });
}

/**
 * ÂÜôÂÖ•Â§±Ë¥•ÂõûË∞É
 */
function failWrite(myDevice: BluetoothDevice | null, errCode: number, errMsg: string): void {
  hideLoading();

  // ‰ºòÂåñÈîôËØØÊèêÁ§∫‰ø°ÊÅØ
  let userFriendlyMessage = errMsg;
  switch (errCode) {
    case 10001:
      userFriendlyMessage = 'ËìùÁâôÊú™ÂºÄÂêØÔºåËØ∑Âú®ËÆæÁΩÆ‰∏≠ÂºÄÂêØËìùÁâôÂêéÈáçËØï';
      break;
    case 10002:
      userFriendlyMessage = 'Êú™ÊâæÂà∞ËìùÁâôËÆæÂ§áÔºåËØ∑Á°Æ‰øùËÆæÂ§áÂ∑≤ÂºÄÂêØ';
      break;
    case 10003:
      userFriendlyMessage = 'ËìùÁâôËøûÊé•Â§±Ë¥•ÔºåËØ∑ÈáçËØï';
      break;
    case 10012:
      userFriendlyMessage = 'ËøûÊé•Ë∂ÖÊó∂ÔºåËØ∑Á°Æ‰øùËÆæÂ§áÂú®ÈôÑËøëÂπ∂ÈáçËØï';
      break;
    case -1:
      userFriendlyMessage = errMsg || 'Êìç‰ΩúÂ§±Ë¥•ÔºåËØ∑ÈáçËØï';
      break;
  }

  uni.showModal({
    content: userFriendlyMessage,
    showCancel: false,
    confirmText: 'ÊàëÁü•ÈÅì‰∫Ü'
  });

  if (myDevice) {
    uni.closeBLEConnection({
      deviceId: myDevice.deviceId,
      complete: _ => null
    });
  }
  uni.closeBluetoothAdapter({ complete: _ => null });
}

/**
 * Â≠óËäÇÊï∞ÁªÑËΩ¨Â≠óÁ¨¶‰∏≤
 */
function byteChar2String(byteArr: number[]): string {
  const arrs: string[] = [];
  for (let i = 0; i < byteArr.length; i++) {
    arrs.push(String.fromCharCode(byteArr[i]));
  }
  return arrs.join('');
}

/**
 * Êï¥Êï∞ËΩ¨ÂçÅÂÖ≠ËøõÂà∂
 */
function int2Hex(i: number): string {
  const hex = Math.abs(i).toString(16);
  if (hex.length === 1) {
    return '0' + hex;
  } else {
    return hex;
  }
}

/**
 * ÂçÅÂÖ≠ËøõÂà∂ËΩ¨Êï¥Êï∞
 */
function hex2Int(hex: string): number {
  const len = hex.length;
  const a = new Array(len);
  let code: number;

  for (let i = 0; i < len; i++) {
    code = hex.charCodeAt(i);
    if (code >= 48 && code < 58) {
      code -= 48;
    } else {
      code = (code & 0xdf) - 65 + 10;
    }
    a[i] = code;
  }

  return a.reduce(function (acc: number, c: number) {
    acc = 16 * acc + c;
    return acc;
  }, 0);
}

/**
 * Âª∂Êó∂ÂáΩÊï∞
 */
function sleep(time: number): void {
  const startTime = new Date().getTime() + parseInt(time.toString(), 10);
  while (new Date().getTime() < startTime) { }
}

/**
 * ÂèëÈÄÅCMDÊåá‰ª§
 */
function postCMD(data: any, successCallback?: (data: any) => void): Promise<any> {
  const url = 'https://gateway.biandianxia.com/encrypt/sharedevice';
  return postData(url, data, successCallback, failCallback);
}

/**
 * ÂèëÈÄÅÁΩëÂÖ≥Êåá‰ª§
 */
function postGateway(data: any, successCallback?: (data: any) => void): Promise<any> {
  const url = 'https://gateway.biandianxia.com/encrypt/gateway';
  return postData(url, data, successCallback, failCallback);
}

/**
 * Êõ¥Êñ∞ÂØÜÈí•
 */
function postUpdateKey(data: any, successCallback?: (data: any) => void): Promise<any> {
  const url = 'https://gateway.biandianxia.com/updateKey';
  return postData(url, data, successCallback, failCallback);
}

/**
 * Ë∞ÉËØïÊó•ÂøóÂäüËÉΩ
 */
function debugLog(message: string, data?: any): void {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`[BLE-DEBUG ${timestamp}] ${message}`, data || '');
  
  // ÂèØÈÄâÔºöÂ∞ÜÊó•Âøó‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®Áî®‰∫éË∞ÉËØï
  try {
    const logs = uni.getStorageSync('ble_debug_logs') || [];
    logs.push({
      timestamp,
      message,
      data: data ? JSON.stringify(data) : null
    });
    
    // Âè™‰øùÁïôÊúÄËøë100Êù°Êó•Âøó
    if (logs.length > 100) {
      logs.splice(0, logs.length - 100);
    }
    
    uni.setStorageSync('ble_debug_logs', logs);
  } catch (error) {
    console.warn('[BLE] ‰øùÂ≠òË∞ÉËØïÊó•ÂøóÂ§±Ë¥•:', error);
  }
}

/**
 * Ëé∑ÂèñË∞ÉËØïÊó•Âøó
 */
function getDebugLogs(): any[] {
  try {
    return uni.getStorageSync('ble_debug_logs') || [];
  } catch (error) {
    console.warn('[BLE] Ëé∑ÂèñË∞ÉËØïÊó•ÂøóÂ§±Ë¥•:', error);
    return [];
  }
}

/**
 * Ê∏ÖÈô§Ë∞ÉËØïÊó•Âøó
 */
function clearDebugLogs(): void {
  try {
    uni.removeStorageSync('ble_debug_logs');
    console.log('[BLE] Ë∞ÉËØïÊó•ÂøóÂ∑≤Ê∏ÖÈô§');
  } catch (error) {
    console.warn('[BLE] Ê∏ÖÈô§Ë∞ÉËØïÊó•ÂøóÂ§±Ë¥•:', error);
  }
}

/**
 * Ëé∑Âèñ Loading Áä∂ÊÄÅ
 */
function getLoadingStatus(): { isLoading: boolean; currentTitle: string } {
  return {
    isLoading: loadingManager.isLoading(),
    currentTitle: loadingManager.getCurrentTitle()
  };
}

// ÂØºÂá∫ÊâÄÊúâÂäüËÉΩ
export {
  // ÁΩëÁªúËØ∑Ê±ÇÂáΩÊï∞
  postCMD,
  postGateway,
  postUpdateKey,

  // ËÆæÂ§áÊ£ÄÊü•ÂáΩÊï∞
  isChargeDevice,
  checkDeviceOnline,
  checkDetailedDeviceStatus,
  writeChargeData,
  checkBluetooth,
  verifyDeviceStatus,

  // Ë∞ÉËØïÂäüËÉΩ
  debugLog,
  getDebugLogs,
  clearDebugLogs,
  getLoadingStatus,

  // Á±ªÂûãÂÆö‰πâ
  type ChargeDeviceInfo,
  type BluetoothDevice,
  type DetailedDeviceStatus,
  type ApiOptions,
  type ApiResponse
};

export default {
  postCMD,
  postGateway,
  postUpdateKey,
  isChargeDevice,
  writeChargeData,
  checkBluetooth,
  checkDeviceOnline,
  checkDetailedDeviceStatus,
  verifyDeviceStatus,
  debugLog,
  getDebugLogs,
  clearDebugLogs,
  getLoadingStatus
}; 